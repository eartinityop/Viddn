name: Playlist Processor and Uploader

on:
  workflow_dispatch:
    inputs:
      playlist_url:
        description: 'YouTube Playlist URL'
        required: true
        type: string
      playback_speed:
        description: 'Desired playback speed (e.g., 1.5 for 1.5x)'
        required: true
        type: number
        default: 1.5
      video_ranges:
        description: 'Comma-separated video ranges to merge (e.g., 1-5,6-10)'
        required: true
        type: string
        default: '1-5,6-10'
      resolution:
        description: 'Video resolution (e.g., 720p, 1080p)'
        required: true
        type: string
        default: '720p'
      release_name:
        description: 'Release Name'
        required: true
        type: string
      video_title:
        description: 'Title for YouTube Video'
        required: true
        type: string

permissions:
  contents: write

jobs:
  process-playlist:
    runs-on: ubuntu-latest
    timeout-minutes: 600  # 10 hours for long playlists

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Install required packages
      run: |
        sudo apt-get update
        sudo apt-get install -y ffmpeg wget bc python3 python3-pip jq
        pip install yt-dlp google-api-python-client google-auth-httplib2 google-auth-oauthlib

    - name: Get playlist information
      run: |
        yt-dlp --flat-playlist --print "%(playlist_index)s. %(webpage_url)s" "${{ github.event.inputs.playlist_url }}" --no-warnings > playlist_urls.txt
        echo "Total videos in playlist: $(wc -l < playlist_urls.txt)"

    - name: Parse video ranges
      shell: bash
      run: |
        # First, check if playlist_urls.txt exists and has content
        if [ ! -f "playlist_urls.txt" ] || [ ! -s "playlist_urls.txt" ]; then
          echo "Error: playlist_urls.txt doesn't exist or is empty"
          exit 1
        fi
    
        echo "Contents of playlist_urls.txt:"
        cat playlist_urls.txt
    
        # Parse the input ranges
        CLEAN_RANGES=$(echo "${{ github.event.inputs.video_ranges }}" | tr -d ' ')
        IFS=',' read -ra RANGES <<< "$CLEAN_RANGES"
        RANGE_COUNT=0
        
        for range in "${RANGES[@]}"; do
          RANGE_COUNT=$((RANGE_COUNT + 1))
          IFS='-' read -ra RANGE_PARTS <<< "$range"
          START=${RANGE_PARTS[0]}
          END=${RANGE_PARTS[1]}
          
          echo "Processing range $RANGE_COUNT: $START to $END"

          # Create a file to store URLs for this range
          RANGE_FILE="range_${RANGE_COUNT}_urls.txt"
          > "$RANGE_FILE"  # Clear the file if it exists already

          # Extract URLs for this range
          for i in $(seq $START $END); do
            # Handle both with and without leading zeros
            URL=$(grep -E "^0*$i\." playlist_urls.txt | cut -d' ' -f2-)
            if [ -n "$URL" ]; then
              echo "$URL" >> "$RANGE_FILE"  # Fixed: was echoing "URL" instead of $URL
              echo "Found URL for video $i: $URL"
            else
              echo "Warning: No URL found for video $i"
            fi
          done
          
          # Store the range file name as an environment variable
          echo "RANGE_${RANGE_COUNT}_FILE=$RANGE_FILE" >> $GITHUB_ENV
        done
      
        echo "RANGE_COUNT=$RANGE_COUNT" >> $GITHUB_ENV

    - name: Process each range
      run: |
        for range_index in $(seq 1 $RANGE_COUNT); do
          echo "Processing range $range_index"
          
          # Get the file containing URLs for this range
          RANGE_FILE_VAR="RANGE_${range_index}_FILE"
          RANGE_FILE=${!RANGE_FILE_VAR}
          
          # Check if the range file exists and has content
          if [ ! -f "$RANGE_FILE" ] || [ ! -s "$RANGE_FILE" ]; then
            echo "Error: File $RANGE_FILE doesn't exist or is empty"
            exit 1
          fi
          
          # Read URLs from the file
          VIDEO_INDEX=0
          while IFS= read -r URL || [ -n "$URL" ]; do
            # Skip empty lines
            if [ -z "$URL" ]; then
              continue
            fi
            
            VIDEO_INDEX=$((VIDEO_INDEX + 1))
            
            echo "Getting direct download URL for: $URL"
            
            # Get direct download URL using yt-dlp
            DIRECT_URL=$(yt-dlp -f "best[height<=${{ github.event.inputs.resolution }}]" -g "$URL" 2>/dev/null | head -1)
            
            if [ -n "$DIRECT_URL" ]; then
              echo "Downloading: $DIRECT_URL"
              wget -O "video_${range_index}_${VIDEO_INDEX}.mp4" "$DIRECT_URL"
            else
              echo "Failed to get direct URL for: $URL"
              # Try alternative method if direct URL fails
              yt-dlp -f "best[height<=${{ github.event.inputs.resolution }}]" -o "video_${range_index}_${VIDEO_INDEX}.mp4" "$URL"
            fi
          done < "$RANGE_FILE"
          
          # If no videos were downloaded, skip the rest
          if [ $VIDEO_INDEX -eq 0 ]; then
            echo "No videos downloaded for range $range_index, skipping."
            continue
          fi
          
          # Create file list for concatenation
          for i in $(seq 1 $VIDEO_INDEX); do
            echo "file 'video_${range_index}_${i}.mp4'" >> "filelist_${range_index}.txt"
          done
          
          # Merge videos
          ffmpeg -f concat -safe 0 -i "filelist_${range_index}.txt" -c copy "merged_${range_index}.mp4"
          
          # Process with speed adjustment
          SPEED_FACTOR=$(echo "scale=10; 1 / ${{ github.event.inputs.playback_speed }}" | bc)
          
          ffmpeg -i "merged_${range_index}.mp4" \
          -filter_complex "[0:v]setpts=${SPEED_FACTOR}*PTS[v];[0:a]atempo=${{ github.event.inputs.playback_speed }}[a]" \
          -map "[v]" -map "[a]" \
          -c:v libx264 -profile:v main -level 4.0 -pix_fmt yuv420p \
          -c:a aac -b:a 128k \
          -movflags +faststart \
          "processed_range_${range_index}.mp4"
          
          # Cleanup temporary files
          rm -f "filelist_${range_index}.txt" "merged_${range_index}.mp4"
          for i in $(seq 1 $VIDEO_INDEX); do
            rm -f "video_${range_index}_${i}.mp4"
          done
        done

    - name: Create Release
      id: create_release
      uses: softprops/action-gh-release@v1
      with:
        tag_name: playlist-${{ github.run_id }}
        name: "${{ github.event.inputs.release_name }}"
        body: |
          Playlist processed with ranges: ${{ github.event.inputs.video_ranges }}
          - Playlist URL: ${{ github.event.inputs.playlist_url }}
          - Resolution: ${{ github.event.inputs.resolution }}
          - Speed: ${{ github.event.inputs.playback_speed }}x
        draft: false
        prerelease: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Upload processed ranges to Release
      run: |
        for i in $(seq 1 $RANGE_COUNT); do
          if [ -f "processed_range_${i}.mp4" ]; then
            echo "Uploading range $i to release"
            
            curl -s \
              -X POST \
              -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              -H "Content-Type: application/octet-stream" \
              --data-binary @"processed_range_${i}.mp4" \
              "https://uploads.github.com/repos/${{ github.repository }}/releases/${{ steps.create_release.outputs.id }}/assets?name=range_${i}.mp4"
          fi
        done

    - name: Generate YouTube access token
      run: |
        response=$(curl -s \
          -d "client_id=${{ secrets.YOUTUBE_CLIENT_ID }}" \
          -d "client_secret=${{ secrets.YOUTUBE_CLIENT_SECRET }}" \
          -d "refresh_token=${{ secrets.YOUTUBE_REFRESH_TOKEN }}" \
          -d "grant_type=refresh_token" \
          "https://oauth2.googleapis.com/token")
        
        access_token=$(echo $response | jq -r '.access_token')
        echo "ACCESS_TOKEN=$access_token" >> $GITHUB_ENV

    - name: Upload to YouTube
      run: |
        # Download the upload script
        wget -q https://raw.githubusercontent.com/eartinityop/Viddn/YT/youtube_upload.py
        
        for i in $(seq 1 $RANGE_COUNT); do
          if [ -f "processed_range_${i}.mp4" ]; then
            VIDEO_FILE="processed_range_${i}.mp4"
            TITLE="${{ github.event.inputs.video_title }} - Range $i"
            DESCRIPTION="Range $i of $RANGE_COUNT. Processed at ${{ github.event.inputs.playback_speed }}x speed from playlist"
            
            echo "Uploading range $i to YouTube..."
            
            python3 youtube_upload.py \
              --file "$VIDEO_FILE" \
              --title "$TITLE" \
              --description "$DESCRIPTION" \
              --access_token "$ACCESS_TOKEN" \
              --privacy "private"
          fi
        done

    - name: Final cleanup
      run: |
        # Clean up all processed files
        rm -f playlist_urls.txt
        for i in $(seq 1 $RANGE_COUNT); do
          rm -f "range_${i}_urls.txt"
          rm -f "processed_range_${i}.mp4"
        done
        rm -f youtube_upload.py

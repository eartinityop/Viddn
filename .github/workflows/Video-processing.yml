name: Playlist Processor and Uploader

on:
  workflow_dispatch:
    inputs:
      playlist_url:
        description: 'YouTube Playlist URL'
        required: true
        type: string
      playback_speed:
        description: 'Desired playback speed (e.g., 1.5 for 1.5x)'
        required: true
        type: number
        default: 1.5
      video_ranges:
        description: 'Comma-separated video ranges to merge (e.g., 1-5,6-10)'
        required: true
        type: string
        default: '1-5,6-10'
      resolution:
        description: 'Video resolution (e.g., 720p, 1080p)'
        required: true
        type: string
        default: '720p'
      release_name:
        description: 'Release Name'
        required: true
        type: string
      video_title:
        description: 'Title for YouTube Video'
        required: true
        type: string

permissions:
  contents: write

jobs:
  process-playlist:
    runs-on: ubuntu-latest
    timeout-minutes: 600  # 10 hours for long playlists

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Install required packages
      run: |
        sudo apt-get update
        sudo apt-get install -y ffmpeg wget bc python3 python3-pip jq
        pip install yt-dlp google-api-python-client google-auth-httplib2 google-auth-oauthlib

    - name: Get all playlist URLs with proper numbering
      run: |
        yt-dlp --get-url --flat-playlist "${{ github.event.inputs.playlist_url }}" -o "%(title)s - %(url)s" > playlist_urls.txt
        echo "Total videos in playlist: $(wc -l < playlist_urls.txt)"

    - name: Parse video ranges and create range files
      shell: bash
      run: |
        # First, check if playlist_urls.txt exists and has content
        if [ ! -f "playlist_urls.txt" ] || [ ! -s "playlist_urls.txt" ]; then
          echo "Error: playlist_urls.txt doesn't exist or is empty"
          exit 1
        fi
    
        echo "Contents of playlist_urls.txt:"
        cat playlist_urls.txt
    
        # Parse the input ranges
        CLEAN_RANGES=$(echo "${{ github.event.inputs.video_ranges }}" | tr -d ' ')
        IFS=',' read -ra RANGES <<< "$CLEAN_RANGES"
        RANGE_COUNT=0
        
        for range in "${RANGES[@]}"; do
          RANGE_COUNT=$((RANGE_COUNT + 1))
          IFS='-' read -ra RANGE_PARTS <<< "$range"
          START=${RANGE_PARTS[0]}
          END=${RANGE_PARTS[1]}
          
          echo "Processing range $RANGE_COUNT: $START to $END"

          # Create a file to store YouTube URLs for this range
          YT_RANGE_FILE="yt_range_${RANGE_COUNT}_urls.txt"
          > "$YT_RANGE_FILE"  # Clear the file if it exists already

          # Extract YouTube URLs for this range
          for i in $(seq $START $END); do
            # Get the YouTube URL for this index
            URL=$(sed -n "${i}p" playlist_urls.txt | cut -d' ' -f3-)
            if [ -n "$URL" ]; then
              echo "$URL" >> "$YT_RANGE_FILE"
              echo "Found YouTube URL for video $i: $URL"
            else
              echo "Warning: No YouTube URL found for video $i"
            fi
          done
          
          # Store the range file name as an environment variable
          echo "YT_RANGE_${RANGE_COUNT}_FILE=$YT_RANGE_FILE" >> $GITHUB_ENV
        done
      
        echo "RANGE_COUNT=$RANGE_COUNT" >> $GITHUB_ENV

    - name: Generate direct download links for each range
      run: |
        for range_index in $(seq 1 $RANGE_COUNT); do
          echo "Generating direct download links for range $range_index"
          
          # Get the file containing YouTube URLs for this range
          YT_RANGE_FILE_VAR="YT_RANGE_${range_index}_FILE"
          YT_RANGE_FILE=${!YT_RANGE_FILE_VAR}
          
          # Check if the range file exists and has content
          if [ ! -f "$YT_RANGE_FILE" ] || [ ! -s "$YT_RANGE_FILE" ]; then
            echo "Error: File $YT_RANGE_FILE doesn't exist or is empty"
            exit 1
          fi
          
          # Create output file for direct download links
          DIRECT_LINKS_FILE="direct_links_range_${range_index}.txt"
          > "$DIRECT_LINKS_FILE"  # Clear the file if it exists
          
          # Read YouTube URLs from the file and generate direct download links
          LINE_NUMBER=1
          while IFS= read -r YT_URL || [ -n "$YT_URL" ]; do
            # Skip empty lines
            if [ -z "$YT_URL" ]; then
              continue
            fi
            
            echo "Processing: $YT_URL"
            
            # Get direct download link using yt-dlp
            DIRECT_LINK=$(yt-dlp -g -f "best[height<=${{ github.event.inputs.resolution }}]" "$YT_URL" 2>/dev/null | head -1)
            
            if [ -n "$DIRECT_LINK" ]; then
              # Format the number with leading zero for single-digit numbers
              printf -v FORMATTED_NUMBER "%02d" "$LINE_NUMBER"
              
              # Write to output file with proper numbering
              echo "$FORMATTED_NUMBER. $DIRECT_LINK" >> "$DIRECT_LINKS_FILE"
              echo "Direct download link saved: $DIRECT_LINK"
            else
              echo "Warning: Failed to get direct download link for: $YT_URL"
            fi
            
            # Increment line number
            LINE_NUMBER=$((LINE_NUMBER + 1))
            
            # Add a small delay to avoid overwhelming servers
            sleep 1
          done < "$YT_RANGE_FILE"
          
          echo "Direct download links for range $range_index saved to $DIRECT_LINKS_FILE"
          
          # Store the direct links file name as an environment variable
          echo "DIRECT_LINKS_${range_index}_FILE=$DIRECT_LINKS_FILE" >> $GITHUB_ENV
        done

    - name: Process each range with direct download links
      run: |
        for range_index in $(seq 1 $RANGE_COUNT); do
          echo "Processing range $range_index with direct download links"
          
          # Get the file containing direct download links for this range
          DIRECT_LINKS_FILE_VAR="DIRECT_LINKS_${range_index}_FILE"
          DIRECT_LINKS_FILE=${!DIRECT_LINKS_FILE_VAR}
          
          # Check if the direct links file exists and has content
          if [ ! -f "$DIRECT_LINKS_FILE" ] || [ ! -s "$DIRECT_LINKS_FILE" ]; then
            echo "Error: File $DIRECT_LINKS_FILE doesn't exist or is empty"
            exit 1
          fi
          
          # Read direct download links from the file
          VIDEO_INDEX=0
          while IFS= read -r LINE || [ -n "$LINE" ]; do
            # Skip empty lines
            if [ -z "$LINE" ]; then
              continue
            fi
            
            # Extract the direct download URL (remove the numbering)
            DIRECT_URL=$(echo "$LINE" | cut -d' ' -f2-)
            
            if [ -n "$DIRECT_URL" ]; then
              VIDEO_INDEX=$((VIDEO_INDEX + 1))
              
              echo "Downloading video $VIDEO_INDEX from direct URL"
              wget -O "video_${range_index}_${VIDEO_INDEX}.mp4" "$DIRECT_URL"
            fi
          done < "$DIRECT_LINKS_FILE"
          
          # If no videos were downloaded, skip the rest
          if [ $VIDEO_INDEX -eq 0 ]; then
            echo "No videos downloaded for range $range_index, skipping."
            continue
          fi
          
          # Create file list for concatenation
          for i in $(seq 1 $VIDEO_INDEX); do
            echo "file 'video_${range_index}_${i}.mp4'" >> "filelist_${range_index}.txt"
          done
          
          # Merge videos
          ffmpeg -f concat -safe 0 -i "filelist_${range_index}.txt" -c copy "merged_${range_index}.mp4"
          
          # Process with speed adjustment
          SPEED_FACTOR=$(echo "scale=10; 1 / ${{ github.event.inputs.playback_speed }}" | bc)
          
          ffmpeg -i "merged_${range_index}.mp4" \
          -filter_complex "[0:v]setpts=${SPEED_FACTOR}*PTS[v];[0:a]atempo=${{ github.event.inputs.playback_speed }}[a]" \
          -map "[v]" -map "[a]" \
          -c:v libx264 -profile:v main -level 4.0 -pix_fmt yuv420p \
          -c:a aac -b:a 128k \
          -movflags +faststart \
          "processed_range_${range_index}.mp4"
          
          # Cleanup temporary files for this range
          rm -f "filelist_${range_index}.txt" "merged_${range_index}.mp4"
          for i in $(seq 1 $VIDEO_INDEX); do
            rm -f "video_${range_index}_${i}.mp4"
          done
        done


    - name: Create Release
      id: create_release
      uses: softprops/action-gh-release@v1
      with:
        tag_name: playlist-${{ github.run_id }}
        name: "${{ github.event.inputs.release_name }}"
        body: |
          Playlist processed with ranges: ${{ github.event.inputs.video_ranges }}
          - Playlist URL: ${{ github.event.inputs.playlist_url }}
          - Resolution: ${{ github.event.inputs.resolution }}
          - Speed: ${{ github.event.inputs.playback_speed }}x
        draft: false
        prerelease: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Upload processed ranges to Release
      run: |
        for i in $(seq 1 $RANGE_COUNT); do
          if [ -f "processed_range_${i}.mp4" ]; then
            echo "Uploading range $i to release"
            
            curl -s \
              -X POST \
              -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              -H "Content-Type: application/octet-stream" \
              --data-binary @"processed_range_${i}.mp4" \
              "https://uploads.github.com/repos/${{ github.repository }}/releases/${{ steps.create_release.outputs.id }}/assets?name=range_${i}.mp4"
          fi
        done

    - name: Generate YouTube access token
      run: |
        response=$(curl -s \
          -d "client_id=${{ secrets.YOUTUBE_CLIENT_ID }}" \
          -d "client_secret=${{ secrets.YOUTUBE_CLIENT_SECRET }}" \
          -d "refresh_token=${{ secrets.YOUTUBE_REFRESH_TOKEN }}" \
          -d "grant_type=refresh_token" \
          "https://oauth2.googleapis.com/token")
        
        access_token=$(echo $response | jq -r '.access_token')
        echo "ACCESS_TOKEN=$access_token" >> $GITHUB_ENV

    - name: Upload to YouTube
      run: |
        # Download the upload script
        wget -q https://raw.githubusercontent.com/eartinityop/Viddn/YT/youtube_upload.py
        
        for i in $(seq 1 $RANGE_COUNT); do
          if [ -f "processed_range_${i}.mp4" ]; then
            VIDEO_FILE="processed_range_${i}.mp4"
            TITLE="${{ github.event.inputs.video_title }} - Range $i"
            DESCRIPTION="Range $i of $RANGE_COUNT. Processed at ${{ github.event.inputs.playback_speed }}x speed from playlist"
            
            echo "Uploading range $i to YouTube..."
            
            python3 youtube_upload.py \
              --file "$VIDEO_FILE" \
              --title "$TITLE" \
              --description "$DESCRIPTION" \
              --access_token "$ACCESS_TOKEN" \
              --privacy "private"
          fi
        done

    - name: Final cleanup
      run: |
        # Clean up all processed files
        rm -f playlist_urls.txt
        for i in $(seq 1 $RANGE_COUNT); do
          rm -f "range_${i}_urls.txt"
          rm -f "processed_range_${i}.mp4"
        done
        rm -f youtube_upload.py
